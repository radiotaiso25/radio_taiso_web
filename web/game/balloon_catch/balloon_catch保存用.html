<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>æ‰‹ã‚­ãƒ£ãƒƒãƒã‚²ãƒ¼ãƒ </title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    canvas { border: 1px solid black; max-width: 100%; height: auto; }
    #score { font-size: 20px; margin: 10px; }
    #unlock-audio {
      position: absolute; right: 10px; top: 10px;
      padding: 6px 10px; font-size: 14px; display: none;
    }
    body { margin: 0; overflow: hidden; }
  </style>

  <!-- âœ… åŒãƒ•ã‚©ãƒ«ãƒ€ã®CSSã‚’èª­ã¿è¾¼ã‚€ï¼ˆãƒ•ã‚¡ã‚¤ãƒ«åã¯å¿…è¦ã«å¿œã˜ã¦å¤‰æ›´/è¿½åŠ ã—ã¦ãã ã•ã„ï¼‰ -->
  <link rel="stylesheet" href="{{ url_for('game_asset', slug='balloon_catch', asset='balloon_catch.css') }}">
</head>
<body>
  <video id="video" autoplay playsinline style="display:none;"></video>
  <canvas id="canvas"></canvas>
  <div id="score">ã‚¹ã‚³ã‚¢: 0</div>
  <button id="unlock-audio">ğŸ”Š éŸ³ã‚’æœ‰åŠ¹ã«ã™ã‚‹</button>

  <!-- TensorFlow.jsã¨handposeãƒ¢ãƒ‡ãƒ« -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-core"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow-models/handpose"></script>

  <script>
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const unlockBtn = document.getElementById('unlock-audio');

    let model;
    let score = 0;
    let frameCount = 0;
    let handRects = [];

    const ball = { x: 200, y: 0, radius: 24, speed: 3.2 };

    // é¢¨èˆ¹ç”»åƒï¼ˆåŒãƒ•ã‚©ãƒ«ãƒ€ï¼‰
    const balloonImg = new Image();
    balloonImg.src = "{{ url_for('game_asset', slug='balloon_catch', asset='balloon.png') }}";
    let balloonReady = false;
    balloonImg.onload = () => { balloonReady = true; };

    // åŠ¹æœéŸ³ï¼ˆåŒãƒ•ã‚©ãƒ«ãƒ€ï¼‰
    const catchSound = new Audio("{{ url_for('game_asset', slug='balloon_catch', asset='catch.mp3') }}");
    catchSound.preload = "auto";
    catchSound.volume = 0.9;

    async function setupCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
      video.srcObject = stream;
      return new Promise(resolve => { video.onloadedmetadata = () => resolve(); });
    }

    function resizeCanvas() {
      // ã‚«ãƒ¡ãƒ©æ¯”ã«åˆã‚ã›ã¦ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’èª¿æ•´ï¼ˆåˆå›ã¨ãƒªã‚µã‚¤ã‚ºæ™‚ï¼‰
      const w = video.videoWidth || 640;
      const h = video.videoHeight || 480;
      canvas.width = w;
      canvas.height = h;
    }

    async function main() {
      await setupCamera();
      video.play();
      resizeCanvas();
      window.addEventListener('resize', resizeCanvas);

      model = await handpose.load();
      requestAnimationFrame(update);
    }

    async function update() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      // ãƒŸãƒ©ãƒ¼è¡¨ç¤ºï¼ˆæ˜ åƒï¼‰
      ctx.save(); ctx.scale(-1, 1); ctx.translate(-canvas.width, 0);
      ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
      ctx.restore();

      // æ‰‹ã®æ¤œå‡ºï¼ˆ2ãƒ•ãƒ¬ãƒ¼ãƒ ã«1å›ï¼‰
      if (frameCount % 2 === 0) {
        const predictions = await model.estimateHands(video);
        handRects = [];
        for (const hand of predictions) {
          const xs = hand.landmarks.map(p => p[0]);
          const ys = hand.landmarks.map(p => p[1]);
          const minX = Math.min(...xs), maxX = Math.max(...xs);
          const minY = Math.min(...ys), maxY = Math.max(...ys);
          const mirroredMinX = canvas.width - maxX;
          const mirroredMaxX = canvas.width - minX;
          handRects.push({ x: mirroredMinX, y: minY, width: mirroredMaxX - mirroredMinX, height: maxY - minY });
        }
      }
      frameCount++;

      // ãƒ‡ãƒãƒƒã‚°ï¼šæ‰‹ã®æ 
      for (const rect of handRects) {
        ctx.strokeStyle = 'red';
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
      }

      // é¢¨èˆ¹æç”»ï¼ˆç”»åƒ or å††ï¼‰
      let effR = ball.radius;
      if (balloonReady) {
        const targetH = Math.max(70, Math.min(110, ball.radius * 3.2));
        const ratio = balloonImg.naturalWidth / balloonImg.naturalHeight || 0.7;
        const targetW = targetH * ratio;
        ctx.drawImage(balloonImg, ball.x - targetW/2, ball.y - targetH/2, targetW, targetH);
        effR = Math.max(targetW, targetH) * 0.45; // å½“ãŸã‚Šåˆ¤å®šã®åŠå¾„è¿‘ä¼¼
      } else {
        ctx.beginPath(); ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI*2);
        ctx.fillStyle = 'blue'; ctx.fill();
      }

      // è½ä¸‹
      ball.y += ball.speed;

      // ã‚­ãƒ£ãƒƒãƒåˆ¤å®š
      for (const rect of handRects) {
        if (ball.x > rect.x && ball.x < rect.x + rect.width &&
            ball.y + effR > rect.y && ball.y - effR < rect.y + rect.height) {
          playCatchSound();
          score++;
          scoreEl.textContent = `ã‚¹ã‚³ã‚¢: ${score}`;
          resetBall();
          break;
        }
      }

      // ç”»é¢å¤–ã§ãƒªã‚»ãƒƒãƒˆ
      if (ball.y - effR > canvas.height) resetBall();

      requestAnimationFrame(update);
    }

    function resetBall() {
      ball.x = Math.random() * canvas.width;
      ball.y = -20;
      ball.speed = 3 + Math.random() * 2;
    }

    async function playCatchSound() {
      try {
        catchSound.currentTime = 0;
        await catchSound.play();
      } catch (e) {
        unlockBtn.style.display = 'inline-block';
      }
    }

    unlockBtn.addEventListener('click', async () => {
      try {
        await catchSound.play();
        catchSound.pause();
        catchSound.currentTime = 0;
        unlockBtn.style.display = 'none';
      } catch (e) {}
    });

    // å¤–éƒ¨JSã‹ã‚‰ä½¿ãˆã‚‹ã‚ˆã†æœ€ä½é™ã®ãƒ•ãƒƒã‚¯ã‚’å…¬é–‹ï¼ˆä»»æ„ï¼‰
    window.balloonGame = {
      resetBall, playCatchSound,
      get state() { return { score, handRects: [...handRects], ball: { ...ball } }; }
    };

    main();
  </script>

  <!-- âœ… åŒãƒ•ã‚©ãƒ«ãƒ€ã®JSã‚’èª­ã¿è¾¼ã‚€ï¼ˆå¿…è¦ã«å¿œã˜ã¦å¢—ã‚„ã—ã¦ãã ã•ã„ï¼‰ -->
  <script src="{{ url_for('game_asset', slug='balloon_catch', asset='balloon_catch.js') }}"></script>
</body>
</html>
